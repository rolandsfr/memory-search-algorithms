\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage[latvian]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{minted}


\geometry{a4paper, margin=1.5cm}


\title{Mājas darbs \#5 - Atmiņas fragmentācija}
\author{Rolands Frīdemanis, rf23009 \\ Agris Pudāns, ap08426}
\date{}

\begin{document}
	
	\maketitle
	
	\tableofcontents
	
	\section{Ievads}
	
	Projekta komandas dalībnieki ir Agris Pudāns un Rolands Frīdemanis. Katra dalībnieka ieguldījums ir vērtējams 50/100.
	
	Projekts ir veidots, lai testētu un salīdzinātu dažādus atmiņas rezervēšanas algoritmus. Testa kopām ir izvmantota viena no publiskajām - [https://selavo-lv.translate.goog/kursi/lsp/2013/mem-frag-tests/mem-frag-tests-2.zip]. Tā struktūra ir organizēta šādi:
	
	\begin{itemize}
		\item \textbf{Galvenais fails (\texttt{main.c})}: Apstrādā ievadi, izvēlas atbilstošo algoritmu un izpilda to.
		\item \textbf{Bibliotēkas}:
		\begin{itemize}
			\item \textbf{cli}: Komandlīnijas interfeiss parametru apstrādei
			\item \textbf{algorithms}: Dažādu atmiņas rezervēšanas algoritmu realizācijas
			\item \textbf{parsers}: Funkcijas failu lasīšanai un skaitļu parsēšanai
			\item \textbf{utils}: Atbalsta funkcijas, piemēram, fragmentācijas aprēķināšanai
		\end{itemize}
	\end{itemize}
	
	Projekts implementē sekojošus atmiņas rezervēšanas algoritmus:
	\begin{itemize}
		\item \textbf{Best Fit}: Meklē mazāko pieejamo atmiņas bloku, kas ir pietiekami liels. Šis algoritms cenšas minimizēt iekšējo fragmentāciju, izvēloties bloku, kas vistuvāk atbilst nepieciešamajam izmēram.
		\item \textbf{First Fit}: Izmanto pirmo pieejamo bloku, kas ir pietiekami liels. Šis ir vienkāršākais un bieži vien efektīvākais algoritms.
		\item \textbf{Next Fit}: Līdzīgs First Fit, bet turpina meklēšanu no pēdējā izdalītā bloka, lai paātrinātu meklēšanas procesu.
		\item \textbf{Worst Fit}: Meklē lielāko pieejamo bloku atmiņā. Šis algoritms cenšas maksimizēt atlikušos fragmentus, lai tie būtu pietiekami lieli nākamajiem pieprasījumiem, bet var radīt lielāku iekšējo fragmentāciju.
	\end{itemize}
	
	Projekts izmanto vienvirziena saistīto sarakstu, lai attēlotu atmiņu, kur katrs mezgls satur informāciju par bloka izmēru un to, vai tas ir brīvs vai aizņemts. Saistītā saraksta struktūra ir definēta šādi:
	
	\begin{minted}[linenos, breaklines, fontsize=\small, autogobble, tabsize=4]{c}
		typedef struct Node {
			long int value;     /* Atmiņas bloka izmērs */
			int is_free;        /* Indikators, vai bloks ir brīvs (1) vai aizņemts (0) */
			struct Node* next;  /* Norāde uz nākamo saraksta mezglu */
		} Node;
	\end{minted}
	
	\section{Atmiņas rezervēšanas algoritmu realizācijas}
	
	\subsection{First Fit algoritma realizācija}
	
	First Fit algoritma laika sarežģītība:
	\begin{itemize}
		\item Vidējais gadījums: O(n), kur n ir bloku skaits
		\item Sliktākais gadījums: O(n)
	\end{itemize}
	
	First Fit vienmēr sāk meklēšanu no saraksta sākuma, tāpēc tas var būt lēnāks algoritms, jo katra pieprasījuma gadījumā ir jāmeklē no sākuma. Tomēr tas bieži vien ir ātrāks nekā Best Fit, jo tam nav jāmeklē visoptimālākais bloks.
	
	Algoritma realizācija ir šāda:
	
	\begin{minted}[linenos, breaklines, fontsize=\small, autogobble, tabsize=4]{c}
		Node* find_first_fit(int size, Node* memory) {
			Node* curr = memory;
			
			while (curr != NULL) {
				if (curr->is_free && curr->value >= size) {
					return curr;
				}
				curr = curr->next;
			}
			
			return NULL; 
		}
	\end{minted}
	
	\subsection{Next Fit algoritma realizācija}
	
	Next Fit algoritma laika sarežģītība:
	\begin{itemize}
		\item Vidējais gadījums: O(n), kur n ir bloku skaits
		\item Sliktākais gadījums: O(n)
	\end{itemize}
	
	Next Fit teorētiski var būt ātrāks nekā First Fit, jo tas turpina meklēšanu no pēdējā izdalītā bloka, nevis sāk no saraksta sākuma. Tomēr realitātē tā efektivitāte ir atkarīga no pieprasījumu un brīvo bloku izvietojuma.
	
	Algoritma realizācija ir šāda:
	
	\begin{minted}[linenos, breaklines, fontsize=\small, autogobble, tabsize=4]{c}
		Node* find_next_fit(int size, Node* memory, Node** last_alloc) {
			Node* curr = *last_alloc ? (*last_alloc)->next : memory;
			
			while (curr != NULL) {
				if (curr->is_free && curr->value >= size) {
					*last_alloc = curr;
					return curr;
				}
				curr = curr->next;
			}
			
			curr = memory;
			while (curr != *last_alloc) {
				if (curr->is_free && curr->value >= size) {
					*last_alloc = curr;
					return curr;
				}
				curr = curr->next;
			}
			
			return NULL; 
		}
	\end{minted}
	
	\subsection{Best Fit algoritma realizācija}
	
	Best Fit algoritma laika sarežģītība:
	\begin{itemize}
		\item Vidējais gadījums: O(n), kur n ir bloku skaits
		\item Sliktākais gadījums: O(n)
	\end{itemize}
	
	Best Fit algoritms pārskata visus pieejamos blokus un izvēlas to, kurš ir vistuvāk nepieciešamajam izmēram, bet joprojām pietiekami liels. Šī pieeja cenšas samazināt iekšējo fragmentāciju, bet tai nepieciešams pārskatīt visus blokus, kas padara to lēnāku nekā First Fit vai Next Fit.
	
	Algoritma realizācija ir šāda:
	
	\begin{minted}[linenos, breaklines, fontsize=\small, autogobble, tabsize=4]{c}
		Node* find_min(int start, Node* memory) {
			Node* curr = memory;
			Node* min = NULL;
			
			while (curr != NULL) {
				if (curr->is_free && curr->value >= start) {
					if (min == NULL || curr->value < min->value) {
						min = curr;
						
						if(min->value == start) return min;
					}
				}
				curr = curr->next;
			}
			
			return min; 
		}
	\end{minted}
	
	\subsection{Worst Fit algoritma realizācija}
	
	Worst Fit algoritma laika sarežģītība:
	\begin{itemize}
		\item Vidējais gadījums: O(n), kur n ir bloku skaits
		\item Sliktākais gadījums: O(n)
	\end{itemize}
	
	Worst Fit algoritms ir pretējs Best Fit - tas meklē lielāko pieejamo bloku, lai tajā ievietotu pieprasīto atmiņu. Stratēģijas mērķis ir atstāt pēc iespējas lielākus brīvos fragmentus, cerot, ka tie būs lietderīgi nākotnes pieprasījumiem. Tomēr praksē šis algoritms bieži rada lielāku iekšējo fragmentāciju un sliktāku atmiņas izmantošanu.
	
	Algoritma realizācija ir šāda:
	
	\begin{minted}[linenos, breaklines, fontsize=\small, autogobble, tabsize=4]{c}
		Node* find_max(int start, Node* memory) {
			Node* head = memory;
			Node* curr = memory;
			Node* max = NULL;
			
			while (curr != NULL) {
				if (curr->is_free && curr->value >= start && curr->value <= MEMORY_CAP) {
					if (max == NULL || curr->value > max->value) {
						max = curr;
					}
					
				}
				curr = curr->next;
			}
			
			return max; 
		}
	\end{minted}
	
	\section{Laika mērījumu apraksts}
	
	Visos algoritmos (First Fit, Next Fit, Best Fit un Worst Fit) laika mērījums tiek veikts, izmantojot standarta C bibliotēkas funkciju \texttt{clock()}. Laika mērīšanas process notiek šādi:
	
	\begin{minted}[linenos, breaklines, fontsize=\small, autogobble]{c}
		start = clock();
		
		// ... algoritma izpilde ...
		
		end = clock();
		
		printf(" - Time taken, seconds: %f\n", ((double) (end - start)) / CLOCKS_PER_SEC);
	\end{minted}
	
	Šis ir standarta veids, kā mērīt algoritmu izpildes laiku C valodā. \texttt{CLOCKS\_PER\_SEC} ir konstante, kas norāda pulksteņa tikšķu skaitu sekundē, un tiek izmantota, lai pārveidotu pulksteņa tikšķus sekundēs.
	
	\section{Fragmentācijas mērījuma funkcija}
	
	Fragmentācija ir svarīgs rādītājs atmiņas pārvaldības algoritmu novērtēšanā. Šajā projektā fragmentācija tiek aprēķināta ar \texttt{calculate\_fragmentation} funkciju:
	
	\begin{minted}[linenos, breaklines, fontsize=\small, autogobble]{c}
		double calculate_fragmentation(Node* memory, int largest_request) {
			size_t total_free = 0;
			size_t largest_free_block = 0;
			size_t current_free_block = 0;
			
			Node* curr = memory;
			while (curr != NULL) {
				if (curr->is_free) {
					total_free += curr->value;
					current_free_block += curr->value;
					if (current_free_block > largest_free_block) {
						largest_free_block = current_free_block;
					}
				} else {
					current_free_block = 0;
				}
				curr = curr->next;
			}
			
			if (total_free == 0) return 0.0;
			
			size_t unusable_memory = 0;
			current_free_block = 0;
			curr = memory;
			while (curr != NULL) {
				if (curr->is_free) {
					current_free_block += curr->value;
				} else {
					if (current_free_block > 0 && current_free_block < (size_t)largest_request) {
						unusable_memory += current_free_block;
					}
					current_free_block = 0;
				}
				curr = curr->next;
			}
			
			if (current_free_block > 0 && current_free_block < (size_t)largest_request) {
				unusable_memory += current_free_block;
			}
			
			return (double)unusable_memory / total_free;
		}
	\end{minted}
	
	Šī funkcija aprēķina fragmentācijas koeficientu, kas ir attiecība starp neizmantojamo brīvo atmiņu (brīvie bloki, kas ir mazāki par lielāko pieprasījumu) un kopējo brīvo atmiņu. Funkcijas darbību var sadalīt vairākos posmos:
	
	\begin{enumerate}
		\item \textbf{Kopējās brīvās atmiņas un lielākā brīvā bloka noteikšana}:
		\begin{itemize}
			\item Funkcija vispirms pārstaigā visu saistīto sarakstu, summējot visu brīvo bloku izmērus (\texttt{total\_free}).
			\item Vienlaikus tiek noteikts arī lielākais nepārtrauktais brīvās atmiņas bloks (\texttt{largest\_free\_block}), kas veidojas no secīgiem brīviem blokiem.
			\item Katru reizi, kad ir atrasts aizņemts bloks, nepārtrauktā brīvā bloka skaitīšana tiek atiestatīta (\texttt{current\_free\_block = 0}).
		\end{itemize}
		
		\item \textbf{Neizmantojamās atmiņas noteikšana}:
		\begin{itemize}
			\item Otrajā saraksta traversēšanā funkcija nosaka, cik daudz brīvās atmiņas ir "neizmantojama".
			\item Atmiņas bloks tiek uzskatīts par neizmantojamu, ja tā izmērs ir mazāks par lielāko pieprasījumu (\texttt{largest\_request}).
			\item Tiek pieņemts, ka bloki, kas ir mazāki par lielāko pieprasījumu, nevar tikt izmantoti efektīvi, jo tie nespēj apmierināt lielāko iespējamo pieprasījumu.
			\item Šeit tiek izmantots arī nepārtraukto brīvo bloku koncepts - ja vairāki secīgi brīvi bloki kopā ir mazāki par lielāko pieprasījumu, tie visi tiek uzskatīti par neizmantojamiem.
		\end{itemize}
		
		\item \textbf{Fragmentācijas koeficienta aprēķināšana}:
		\begin{itemize}
			\item Fragmentācijas koeficients tiek aprēķināts kā neizmantojamās brīvās atmiņas attiecība pret kopējo brīvo atmiņu.
			\item Rezultātā iegūstam skaitli robežās no 0 līdz 1, kur:
			\begin{itemize}
				\item 0 nozīmē, ka visa brīvā atmiņa ir izmantojama (nav fragmentācijas).
				\item 1 nozīmē, ka visa brīvā atmiņa ir neizmantojama (pilnīga fragmentācija).
			\end{itemize}
			\item Jo zemāks koeficients, jo efektīvāk algoritms izmanto atmiņu un mazāk rada fragmentāciju.
		\end{itemize}
	\end{enumerate}
	
	Šī metrika ir īpaši noderīga, lai salīdzinātu dažādus atmiņas pārvaldības algoritmus, jo tā ņem vērā praktiskos ierobežojumus - atmiņas bloki, kas ir pārāk mazi, faktiski kļūst nelietojami lielu pieprasījumu gadījumā. Tas ir reāls fragmentācijas efekts, ko algoritmi cenšas minimizēt.
	
	\section{Algoritmu realizācijas novērtējums}
	
	No algoritmu izpildes rezultātiem (sk. 1. tabulu) var analizēt algoritmu veiktspēju un var secināt, ka:
	
	\begin{enumerate}
		\item \textbf{Izpildes laiks}: Next Fit algoritms ir visātrākais (0.000004s), gandrīz 6 reizes ātrāks nekā First Fit (0.000024s), 10 reizes ātrāks nekā Worst Fit (0.000040s) un aptuveni 42 reizes ātrāks nekā Best Fit (0.000168s). Šie rezultāti atbilst teorētiskajām prognozēm, kur algoritmi, kas meklē optimālo bloku (Best Fit), ir lēnāki nekā tie, kas apstājas pie pirmā pieņemamā bloka (First Fit, Next Fit).
		
		\item \textbf{Izdalīto bloku skaits}: First Fit un Next Fit izdalīja vienādu bloku skaitu (99), kas ir ievērojami vairāk nekā Best Fit (56) un Worst Fit (5). Šāda atšķirība liecina par dažādu algoritmu stratēģiju ietekmi uz atmiņas izmantošanas efektivitāti.
		
		\item \textbf{Kopējā izdalītā atmiņa}: First Fit un Next Fit izdalīja vienādu atmiņas apjomu (980 baitus), Best Fit izdalīja 1024 baitus, bet Worst Fit tikai 1000 baitus. Interesanti, ka Best Fit, lai gan izdalīja mazāk bloku, kopā izdalīja vairāk atmiņas, kas liecina par to, ka tas efektīvāk aizpildīja pieejamo atmiņas telpu.
	\end{enumerate}
	
	\begin{table}[h]
		\centering
		\begin{tabular}{lcccc}
			\toprule
			\textbf{Metrika} & \textbf{First Fit} & \textbf{Next Fit} & \textbf{Best Fit} & \textbf{Worst Fit} \\
			\midrule
			Izpildes laiks (sekundes) & 0.000024 & 0.000004 & 0.000168 & 0.000040 \\
			Fragmentācijas koeficients & 0.000005 & 0.000027 & 0.000093 & 0.000031 \\
			Izdalīto bloku skaits & 99 & 99 & 56 & 5 \\
			Kopējā izdalītā atmiņa (baiti) & 980 & 980 & 1024 & 1000 \\
			\bottomrule
		\end{tabular}
		\caption{Visu algoritmu mērījumu rezultāti}
		\label{tab:performance}
	\end{table}
	
	\subsection{Ātrdarbības novērtējums}
	
	Saskaņā ar teorētiskiem apsvērumiem un praktiskiem mērījumiem:
	
	\begin{enumerate}
		\item Next Fit ir visātrākais no visiem testētajiem algoritmiem, kas padara to ideālu lietojumiem, kur svarīgs ir izpildes ātrums.
		
		\item Best Fit ir visslēnākais algoritms, jo tas vienmēr pārmeklē visu sarakstu, lai atrastu optimālo bloku. Šis rezultāts atbilst teorētiski paredzētajam - jo sarežģītāka bloka izvēles stratēģija, jo ilgāks izpildes laiks.
		
		\item Worst Fit ir ātrāks nekā Best Fit, bet lēnāks nekā First Fit un Next Fit. Tas arī atbilst teorētiskajiem priekšstatiem, jo, tāpat kā Best Fit, tam jāpārmeklē viss saraksts, bet atlases kritērijs ir vienkāršāks.
		
		\item Atmiņas izmantošanas efektivitātes ziņā šie algoritmi demonstrē dažādus rezultātus - Next Fit un First Fit izdalīja visvairāk bloku (99), Best Fit izdalīja vidēju bloku skaitu (56), bet Worst Fit izdalīja vismazāk bloku (5), kas liecina par tā neefektivitāti konkrētajā testa scenārijā.
	\end{enumerate}
	
	\subsection{Fragmentācijas novērtējums}
	
	Algoritmu izpildes rezultāti fragmentācijas ziņā ir apkopoti 2. tabulā. Analizējot algoritmu ietekmi uz atmiņas fragmentāciju, var novērot šādas likumsakarības:
	
	\begin{enumerate}
		\item First Fit parasti rada mazāku ārējo fragmentāciju nekā Next Fit, jo tas vienmēr meklē no sākuma un tādējādi biežāk izmanto mazākos pieejamos blokus. Mūsu mērījumi to apstiprina, uzrādot viszemāko fragmentācijas koeficientu (0.000005).
		
		\item Next Fit parasti rada lielāku ārējo fragmentāciju nekā First Fit, jo tas var izlaist mazākus blokus saraksta sākumā. Tā fragmentācijas koeficients (0.000027) ir aptuveni 5.4 reizes augstāks nekā First Fit.
		
		\item Interesanti, ka Best Fit, kas teorētiski būtu jāoptimizē, lai samazinātu fragmentāciju, uzrāda augstāko fragmentācijas koeficientu (0.000093). Tas varētu būt saistīts ar to, ka atmiņa tiek "pārāk optimāli" sadalīta, atstājot mazus, neizmantojamus fragmentus.
		
		\item Worst Fit uzrāda negaidīti zemu fragmentācijas koeficientu (0.000031), kas ir tikai nedaudz augstāks nekā Next Fit. Tas varētu būt skaidrojams ar to, ka Worst Fit izdalīja ļoti maz bloku (5) katru pa 200 baitiem, tādējādi atstājot lielāko daļu atmiņas neskartu un brīvu.
	\end{enumerate}

	\begin{table}[h]
		\centering
		\begin{tabular}{lc}
			\toprule
			\textbf{Algoritms} & \textbf{Fragmentācijas koeficients} \\
			\midrule
			First Fit & 0.000005 \\
			Next Fit & 0.000027 \\
			Best Fit & 0.000093 \\
			Worst Fit & 0.000031 \\
			\bottomrule
		\end{tabular}
		\caption{Visu algoritmu fragmentācijas rezultāti}
		\label{tab:fragmentation}
	\end{table}	

	
	\subsection{Secinājumi par fragmentāciju}
	
	\begin{enumerate}
		\item First Fit uzrāda viszemāko fragmentāciju no visiem algoritmiem, kas padara to piemērotu lietojumiem, kur atmiņas efektīva izmantošana ir prioritāte.
		
		\item Best Fit, pretēji teorētiskajiem paredzējumiem, uzrāda augstāko fragmentācijas koeficientu. Tas liecina, ka teorētiski "optimālākā" bloka izvēle ne vienmēr veda pie visefektīvākās atmiņas izmantošanas praktiskajā testā.
		
		\item Worst Fit, kaut arī izdalīja vismazāk bloku, neuzrādīja augstāko fragmentācijas koeficientu. Tas norāda, ka fragmentācijas līmenis ne vienmēr korelē ar izdalīto bloku skaitu.
		
		\item Kopumā visi algoritmi uzrādīja ļoti zemu fragmentācijas līmeni (koeficienti zem 0.0001), kas liecina, ka šajā konkrētajā testā fragmentācija nebija nozīmīga problēma nevienam no algoritmiem.
	\end{enumerate}
	
	\section{Kopējie secinājumi un labākā algoritma izvēle}
	
	\subsection{Secinājumi algoritmu izvēlei}
	
	\begin{enumerate}
		\item \textbf{Algoritma izvēle atkarīga no lietojuma}:
		\begin{itemize}
			\item \textbf{First Fit} ir labs vispārīgs risinājums, kas nodrošina zemu fragmentāciju un labu izpildes laiku.
			\item \textbf{Next Fit} ir ideāls, kad ātrums ir galvenā prioritāte un fragmentācija ir mazāk svarīga.
			\item \textbf{Best Fit} ir piemērots situācijām, kad vēlamies maksimāli izmantot pieejamo atmiņu, pat ja tas prasa ilgāku izpildes laiku.
			\item \textbf{Worst Fit} šajā testā parādīja sliktākos rezultātus bloku izdalīšanas ziņā, bet var būt noderīgs ļoti specifiskās situācijās, kur vajadzīgs zems fragmentācijas līmenis un ātrs izpildes laiks.
		\end{itemize}
		
		\item \textbf{Realizācijas apsvērumi}:
		\begin{itemize}
			\item Visu algoritmu realizācijas izmanto līdzīgu saistītā saraksta struktūru, kas atvieglo to salīdzināšanu.
			\item Fragmentācijas aprēķināšana ir svarīga algoritmu novērtēšanai un var būt atkarīga no konkrētā lietojuma.
			\item Laika mērījumi ir nepieciešami, lai novērtētu algoritmu praktisko efektivitāti.
		\end{itemize}
		
		\item \textbf{Kompromiss starp ātrdarbību un fragmentāciju}:
		\begin{itemize}
			\item Next Fit ir aptuveni 6 reizes ātrāks nekā First Fit, bet rada 5.4 reizes augstāku fragmentāciju, lai gan abi koeficienti ir ārkārtīgi mazi.
			\item Best Fit ir aptuveni 7 reizes lēnāks nekā Next Fit, bet izdalīja vairāk kopējās atmiņas (1024 pret 980 baitiem).
			\item Worst Fit ir ātrāks nekā Best Fit, bet izdalīja ievērojami mazāk bloku (5 pret 56).
			\item Šajā konkrētajā gadījumā kompromiss starp ātrdarbību un atmiņas izmantošanas efektivitāti ir minimāls, jo visi algoritmi demonstrē ļoti zemu fragmentāciju.
		\end{itemize}
		
		\item \textbf{Optimizācijas iespējas}:
		\begin{itemize}
			\item Visi algoritmi varētu tikt uzlaboti, izmantojot sarežģītākas datu struktūras, piemēram, balansētus kokus vai meklēšanas tabulas.
			\item Konkrētam lietojumam var būt nepieciešams pielāgot algoritmus, piemēram, apvienot blīvi izvietotus brīvos blokus.
			\item Hibrīda pieejas, kas apvieno dažādu algoritmu priekšrocības, varētu būt efektīvākas dažādos scenārijos.
		\end{itemize}
		
	\end{enumerate}
	
	\subsection{Labākā algoritma izvēle}
	
	Ņemot vērā visus mērījumu rezultātus, varam secināt, ka labākā algoritma izvēle ir atkarīga no specifisku prasību prioritātēm:
	
	\begin{itemize}
		\item Ja prioritāte ir \textbf{ātrums}, tad \textbf{Next Fit} ir nepārprotami labākā izvēle, jo tas demonstrē vislabāko izpildes laiku (0.000004s) un spēj izdalīt lielu bloku skaitu (99).
		
		\item Ja prioritāte ir \textbf{maksimāla atmiņas izdalīšana}, tad \textbf{Best Fit} sniedz labākos rezultātus, izdalot visvairāk atmiņas, kas ir vienāda ar maksimālo izmantojamo (1024 baiti), lai gan ir ar ilgāku izpildes laiku un augstāku fragmentāciju.
	\end{itemize}
		
		Kopumā, balstoties uz šiem mērījumiem un analizējot visus algoritmus, \textbf{Next Fit} un \textbf{First Fit} ir vispiemērotākie vispārējai lietošanai:
		
	\begin{itemize}
		\item \textbf{Next Fit} ir optimālā izvēle, kad izpildes ātrums ir kritisks - tas ir ievērojami ātrāks par citiem algoritmiem, izdalīja daudz bloku un uzrādīja pieņemamu fragmentācijas līmeni.
		
		\item \textbf{Best Fit} uzrādīja lēnāku izpildes laiku, bet izdalīja visu atvēlēto atmiņu. Ņemot vērā iespējamās optimizācijas, piemēram, izmantojot BST, šis algoritms ir labākais. 
	\end{itemize}
\end{document}
