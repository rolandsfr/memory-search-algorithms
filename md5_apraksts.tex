\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage[latvian]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{minted}


\geometry{a4paper, margin=1.5cm}


\title{Mājas darbs \#5 - Atmiņas fragmentācija}
\author{Rolands \\ Agris}
\date{}

\begin{document}
	
	\maketitle
	
	\section{Ievads}
	
	Projekts ir veidots, lai testētu un salīdzinātu dažādus atmiņas rezervēšanas algoritmus. Tā struktūra ir organizēta šādi:
	
	\begin{itemize}
		\item \textbf{Galvenais fails (\texttt{main.c})}: Apstrādā ievadi, izvēlas atbilstošo algoritmu un izpilda to.
		\item \textbf{Bibliotēkas}:
		\begin{itemize}
			\item \textbf{cli}: Komandlīnijas interfeiss parametru apstrādei
			\item \textbf{algorithms}: Dažādu atmiņas rezervēšanas algoritmu implementācijas
			\item \textbf{parsers}: Funkcijas failu lasīšanai un skaitļu parsēšanai
			\item \textbf{utils}: Atbalsta funkcijas, piemēram, fragmentācijas aprēķināšanai
		\end{itemize}
	\end{itemize}
	
	Projekts implementē sekojošus atmiņas rezervēšanas algoritmus:
	\begin{itemize}
		\item \textbf{Best Fit}: Meklē mazāko pieejamo atmiņas bloku, kas ir pietiekami liels
		\item \textbf{First Fit}: Izmanto pirmo pieejamo bloku, kas ir pietiekami liels
		\item \textbf{Next Fit}: Līdzīgs First Fit, bet turpina meklēšanu no pēdējā izdalītā bloka
		\item \textbf{Worst Fit}: (Nav pilnībā implementēts)
	\end{itemize}
	
	Projekts izmanto vienvirziena saistīto sarakstu, lai attēlotu atmiņu, kur katrs mezgls satur informāciju par bloka izmēru un to, vai tas ir brīvs vai aizņemts. Saistītā saraksta struktūra ir definēta šādi:
	
	\begin{minted}[linenos, breaklines, fontsize=\small, autogobble, tabsize=4]{c}
		typedef struct Node {
			long int value;     /* Atmiņas bloka izmērs */
			int is_free;        /* Indikators, vai bloks ir brīvs (1) vai aizņemts (0) */
			struct Node* next;  /* Norāde uz nākamo saraksta mezglu */
		} Node;
	\end{minted}
	
	\section{First Fit un Next Fit algoritmu realizācijas}
	
	\subsection{First Fit algoritma implementācija}
	
	First Fit algoritma laika sarežģītība:
	\begin{itemize}
		\item Vidējais gadījums: O(n), kur n ir bloku skaits
		\item Sliktākais gadījums: O(n)
	\end{itemize}
	
	First Fit vienmēr sāk meklēšanu no saraksta sākuma, tāpēc tas var būt lēnāks algoritms, jo katra pieprasījuma gadījumā ir jāmeklē no sākuma. Tomēr tas bieži vien ir ātrāks nekā Best Fit, jo tam nav jāmeklē visoptimālākais bloks.
	
	Algoritma implementācija ir šāda:
	
	\begin{minted}[linenos, breaklines, fontsize=\small, autogobble, tabsize=4]{c}
		Node* find_first_fit(int size, Node* memory) {
			Node* curr = memory;
			
			while (curr != NULL) {
				if (curr->is_free && curr->value >= size) {
					return curr;
				}
				curr = curr->next;
			}
			
			return NULL; 
		}
	\end{minted}
	
	\subsection{Next Fit algoritma implementācija}
	
	Next Fit algoritma laika sarežģītība:
	\begin{itemize}
		\item Vidējais gadījums: O(n), kur n ir bloku skaits
		\item Sliktākais gadījums: O(n)
	\end{itemize}
	
	Next Fit teorētiski var būt ātrāks nekā First Fit, jo tas turpina meklēšanu no pēdējā izdalītā bloka, nevis sāk no saraksta sākuma. Tomēr realitātē tā efektivitāte ir atkarīga no pieprasījumu un brīvo bloku izvietojuma.
	
	Algoritma implementācija ir šāda:
	
	\begin{minted}[linenos, breaklines, fontsize=\small, autogobble, tabsize=4]{c}
		Node* find_next_fit(int size, Node* memory, Node** last_alloc) {
			Node* curr = *last_alloc ? (*last_alloc)->next : memory;
			
			while (curr != NULL) {
				if (curr->is_free && curr->value >= size) {
					*last_alloc = curr;
					return curr;
				}
				curr = curr->next;
			}
			
			curr = memory;
			while (curr != *last_alloc) {
				if (curr->is_free && curr->value >= size) {
					*last_alloc = curr;
					return curr;
				}
				curr = curr->next;
			}
			
			return NULL; 
		}
	\end{minted}
	
	\section{Laika mērījumu apraksts}
	
	Gan First Fit, gan Next Fit algoritmos laika mērījums tiek veikts, izmantojot standarta C bibliotēkas funkciju \texttt{clock()}. Laika mērīšanas process notiek šādi:
	
	\begin{minted}[linenos, breaklines, fontsize=\small, autogobble]{c}
		start = clock();
		
		// ... algoritma izpilde ...
		
		end = clock();
		
		printf(" - Time taken, seconds: %f\n", ((double) (end - start)) / CLOCKS_PER_SEC);
	\end{minted}
	
	Šis ir standarta veids, kā mērīt algoritmu izpildes laiku C valodā. \texttt{CLOCKS\_PER\_SEC} ir konstante, kas norāda pulksteņa tikšķu skaitu sekundē, un tiek izmantota, lai pārveidotu pulksteņa tikšķus sekundēs.
	
	\section{Fragmentācijas mērījuma funkcija}
	
	Fragmentācija ir svarīgs rādītājs atmiņas pārvaldības algoritmu novērtēšanā. Šajā projektā fragmentācija tiek aprēķināta ar \texttt{calculate\_fragmentation} funkciju:
	
	\begin{minted}[linenos, breaklines, fontsize=\small, autogobble]{c}
		double calculate_fragmentation(Node* memory, int largest_request) {
			size_t total_free = 0;
			size_t largest_free_block = 0;
			size_t current_free_block = 0;
			
			Node* curr = memory;
			while (curr != NULL) {
				if (curr->is_free) {
					total_free += curr->value;
					current_free_block += curr->value;
					if (current_free_block > largest_free_block) {
						largest_free_block = current_free_block;
					}
				} else {
					current_free_block = 0;
				}
				curr = curr->next;
			}
			
			if (total_free == 0) return 0.0;
			
			size_t unusable_memory = 0;
			current_free_block = 0;
			curr = memory;
			while (curr != NULL) {
				if (curr->is_free) {
					current_free_block += curr->value;
				} else {
					if (current_free_block > 0 && current_free_block < (size_t)largest_request) {
						unusable_memory += current_free_block;
					}
					current_free_block = 0;
				}
				curr = curr->next;
			}
			
			if (current_free_block > 0 && current_free_block < (size_t)largest_request) {
				unusable_memory += current_free_block;
			}
			
			return (double)unusable_memory / total_free;
		}
	\end{minted}
	
	Šī funkcija aprēķina fragmentācijas koeficientu, kas ir attiecība starp neizmantojamo brīvo atmiņu (brīvie bloki, kas ir mazāki par lielāko pieprasījumu) un kopējo brīvo atmiņu. Funkcijas darbību var sadalīt vairākos posmos:
	
	\begin{enumerate}
		\item \textbf{Kopējās brīvās atmiņas un lielākā brīvā bloka noteikšana}:
		\begin{itemize}
			\item Funkcija vispirms pārstaigā visu saistīto sarakstu, summējot visu brīvo bloku izmērus (\texttt{total\_free}).
			\item Vienlaikus tiek noteikts arī lielākais nepārtrauktais brīvās atmiņas bloks (\texttt{largest\_free\_block}), kas veidojas no secīgiem brīviem blokiem.
			\item Katru reizi, kad ir atrasts aizņemts bloks, nepārtrauktā brīvā bloka skaitīšana tiek atiestatīta (\texttt{current\_free\_block = 0}).
		\end{itemize}
		
		\item \textbf{Neizmantojamās atmiņas noteikšana}:
		\begin{itemize}
			\item Otrajā saraksta traversēšanā funkcija nosaka, cik daudz brīvās atmiņas ir "neizmantojama".
			\item Atmiņas bloks tiek uzskatīts par neizmantojamu, ja tā izmērs ir mazāks par lielāko pieprasījumu (\texttt{largest\_request}).
			\item Tiek pieņemts, ka bloki, kas ir mazāki par lielāko pieprasījumu, nevar tikt izmantoti efektīvi, jo tie nespēj apmierināt lielāko iespējamo pieprasījumu.
			\item Šeit tiek izmantots arī nepārtraukto brīvo bloku koncepts - ja vairāki secīgi brīvi bloki kopā ir mazāki par lielāko pieprasījumu, tie visi tiek uzskatīti par neizmantojamiem.
		\end{itemize}
		
		\item \textbf{Fragmentācijas koeficienta aprēķināšana}:
		\begin{itemize}
			\item Fragmentācijas koeficients tiek aprēķināts kā neizmantojamās brīvās atmiņas attiecība pret kopējo brīvo atmiņu.
			\item Rezultātā iegūstam skaitli robežās no 0 līdz 1, kur:
			\begin{itemize}
				\item 0 nozīmē, ka visa brīvā atmiņa ir izmantojama (nav fragmentācijas).
				\item 1 nozīmē, ka visa brīvā atmiņa ir neizmantojama (pilnīga fragmentācija).
			\end{itemize}
			\item Jo zemāks koeficients, jo efektīvāk algoritms izmanto atmiņu un mazāk rada fragmentāciju.
		\end{itemize}
	\end{enumerate}
	
	Šī metrika ir īpaši noderīga, lai salīdzinātu dažādus atmiņas pārvaldības algoritmus, jo tā ņem vērā praktiskos ierobežojumus - atmiņas bloki, kas ir pārāk mazi, faktiski kļūst nelietojami lielu pieprasījumu gadījumā. Tas ir reāls fragmentācijas efekts, ko algoritmi cenšas minimizēt.
	
	\section{Algoritmu ātrdarbības novērtējums}
		
	No algoritmu izpildes rezultātiem (sk. 1. tabulu) var analizēt algoritmu veiktspēju un var secinānt, ka:
	
	\begin{enumerate}
		\item \textbf{Izpildes laiks}: Next Fit algoritms izpildās aptuveni 6 reizes ātrāk nekā First Fit (0.000004s pret 0.000024s), kas ievērojami pārsniedz teorētiskos paredzējumus. Tas demonstrē Next Fit algoritma priekšrocību, kad tas turpina meklēšanu no pēdējā izdalītā bloka, nevis katru reizi sāk no saraksta sākuma.
		
		\item \textbf{Izdalīto bloku skaits}: Abi algoritmi izdalīja vienādu bloku skaitu (99), kas norāda, ka šajā konkrētajā testu scenārijā abi algoritmi spēja apmierināt tādu pašu pieprasījumu skaitu.
		
		\item \textbf{Kopējā izdalītā atmiņa}: Abi algoritmi izdalīja vienādu atmiņas apjomu (980 baitus), kas atbilst vienādam izdalīto bloku skaitam.
	\end{enumerate}
	
	\begin{table}[h]
		\centering
		\begin{tabular}{lcc}
			\toprule
			\textbf{Metrika} & \textbf{First Fit} & \textbf{Next Fit} \\
			\midrule
			Izpildes laiks (sekundes) & 0.000024 & 0.000004 \\
			Fragmentācijas koeficients & 0.000005 & 0.000027 \\
			Izdalīto bloku skaits & 99 & 99 \\
			Kopējā izdalītā atmiņa (baiti) & 980 & 980 \\
			\bottomrule
		\end{tabular}
		\caption{First Fit un Next Fit algoritmu mērījumu rezultāti}
		\label{tab:performance}
	\end{table}
	
	\subsection{Secinājumi par ātrdarbību}
	
	Saskaņā ar teorētiskiem apsvērumiem un praktiskiem mērījumiem:
	
	\begin{enumerate}
		\item Next Fit ir ievērojami ātrāks nekā First Fit, kā to pierāda mērījumu rezultāti, kas uzrāda 6 reižu ātruma uzlabojumu (0.000004s pret 0.000024s).
		
		\item Abi algoritmi demonstrēja vienādu atmiņas izmantošanas efektivitāti, jo izdalīja vienādu bloku skaitu (99) un vienādu kopējo atmiņas apjomu (980 baitus).
		
		\item Ātrdarbības uzlabojums Next Fit algoritmā šajā gadījumā nenāca ar atmiņas izmantošanas efektivitātes kompromisu, kā bija sagaidāms no teorētiskajiem apsvērumiem.
		
		\item Abiem algoritmiem ir O(n) laika sarežģītība sliktākajā gadījumā, bet praktiskajos rezultātos Next Fit demonstrē ievērojami labāku vidējo veiktspēju šajā konkrētajā scenārijā.
	\end{enumerate}
	
	\subsection{Secinājumi par fragmentāciju}
	Algoritmu izpildes rezultāti apstiprina teorētiskos paredzējumus:

	\begin{table}[h]
		\centering
		\begin{tabular}{lc}
			\toprule
			\textbf{Algoritms} & \textbf{Fragmentācijas koeficients} \\
			\midrule
			First Fit & 0.000005 \\
			Next Fit & 0.000027 \\
			\bottomrule
		\end{tabular}
		\caption{First Fit un Next Fit algoritmu fragmentācijas rezultāti}
		\label{tab:fragmentation}
	\end{table}	
	
	\begin{enumerate}
		\item First Fit parasti rada mazāku ārējo fragmentāciju nekā Next Fit, jo tas vienmēr meklē no sākuma un tādējādi biežāk izmanto mazākos pieejamos blokus. Tomēr tas var radīt lielāku iekšējo fragmentāciju, jo tas izvēlas pirmo derīgo bloku, nevis optimālāko.
		
		\item Next Fit parasti rada lielāku ārējo fragmentāciju nekā First Fit, jo tas var izlaist mazākus blokus saraksta sākumā. Laika gaitā tas var radīt situāciju, kur saraksta sākumā ir daudz mazu, neizmantotu bloku.
	\end{enumerate}
	
	\subsection{Secinājumi par fragmentāciju}
	
	\begin{enumerate}
		\item First Fit uzrāda mazāku fragmentāciju nekā Next Fit, kas apstiprina teorētiskos pieņēmumus, lai gan abi rāda ļoti zemu fragmentācijas līmeni.
		
		\item First Fit fragmentācijas koeficients ir 0.000005, kas ir aptuveni 5.4 reizes zemāks nekā Next Fit (0.000027).
		
		\item Lai gan teorētiski Next Fit augstāka fragmentācija ir saistīta ar tā tendenci izlaist mazākus brīvos blokus saraksta sākumā, šajos testos abi algoritmi demonstrēja praktiski nenozīmīgu fragmentāciju.
		
		\item Ņemot vērā ļoti zemos fragmentācijas koeficientus abiem algoritmiem, fragmentācijas atšķirība šajā gadījumā nav tik kritiska, kaut gan relatīvā starpība ir ievērojama.
	\end{enumerate}
	
	\section{Kopējie secinājumi algoritmu izveidei}
	
	\begin{enumerate}
		\item \textbf{Algoritma izvēle atkarīga no lietojuma}:
		\begin{itemize}
			\item \textbf{First Fit} ir labs vispārīgs risinājums, kas nodrošina labu līdzsvaru starp ātrdarbību un fragmentāciju.
			\item \textbf{Next Fit} ir piemērots gadījumiem, kad ātrums ir svarīgāks par atmiņas efektivitāti.
			\item \textbf{Best Fit} ir labs, kad atmiņas efektivitāte ir svarīgāka par ātrdarbību.
		\end{itemize}
		
		\item \textbf{Implementācijas apsvērumi}:
		\begin{itemize}
			\item Visu algoritmu implementācijas izmanto līdzīgu saistītā saraksta struktūru, kas atvieglo to salīdzināšanu.
			\item Fragmentācijas aprēķināšana ir svarīga algoritmu novērtēšanai un var būt atkarīga no konkrētā lietojuma.
			\item Laika mērījumi ir nepieciešami, lai novērtētu algoritmu praktisko efektivitāti.
		\end{itemize}
		
		\item \textbf{Kompromiss starp ātrdarbību un fragmentāciju}:
		\begin{itemize}
			\item Next Fit ir aptuveni 6 reizes ātrāks nekā First Fit, bet rada 5.4 reizes augstāku fragmentāciju, lai gan abi koeficienti ir ārkārtīgi mazi.
			\item Abi algoritmi izdalīja vienādu bloku skaitu (99) un vienādu atmiņas daudzumu (980 baitus) šajā testu scenārijā.
			\item Šajā konkrētajā gadījumā kompromiss starp ātrdarbību un atmiņas izmantošanas efektivitāti ir minimāls, jo abi algoritmi demonstrē ļoti zemu fragmentāciju.
		\end{itemize}
		
		\item \textbf{Optimizācijas iespējas}:
		\begin{itemize}
			\item First Fit un Next Fit algoritmi varētu tikt uzlaboti, izmantojot sarežģītākas datu struktūras, piemēram, balansētus kokus vai meklēšanas tabulas.
			\item Konkrētam lietojumam var būt nepieciešams pielāgot algoritmus, piemēram, apvienot blīvi izvietotus brīvos blokus.
			\item Hibrīda pieejas, kas apvieno dažādu algoritmu priekšrocības, varētu būt efektīvākas dažādos scenārijos.
		\end{itemize}
		
	\end{enumerate}
	
	\section{Secinājumi un labākā algoritma izvēle}
	
	Ņemot vērā jaunos mērījumu rezultātus, \textbf{Next Fit} var uzskatīt par labāko vispārējo algoritmu no abiem analizētajiem, jo tas piedāvā ievērojami labāku ātrdarbību, bet atmiņas izmantošanas efektivitātes ziņā šajā scenārijā abi algoritmi ir praktiski ekvivalenti - tie izdalīja vienādu bloku skaitu (99) un vienādu atmiņas apjomu (980 baitus). Lai gan First Fit teorētiski nodrošina zemāku fragmentāciju, faktiskā starpība ir tik niecīga (0.000005 pret 0.000027), ka praktiski tā neietekmē sistēmas darbību.
	
\end{document}
